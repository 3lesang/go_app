// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: discount.sql

package product_db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const bulkDeleteDiscounts = `-- name: BulkDeleteDiscounts :exec
DELETE FROM discounts
WHERE id = ANY($1::bigint[])
`

func (q *Queries) BulkDeleteDiscounts(ctx context.Context, dollar_1 []int64) error {
	_, err := q.db.Exec(ctx, bulkDeleteDiscounts, dollar_1)
	return err
}

const countDiscounts = `-- name: CountDiscounts :one
SELECT COUNT(*)
FROM discounts
`

func (q *Queries) CountDiscounts(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countDiscounts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDiscount = `-- name: CreateDiscount :one
INSERT INTO discounts (
  title, description, code, discount_type, status, usage_limit, per_customer_limit, starts_at, ends_at
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id
`

type CreateDiscountParams struct {
	Title            string           `json:"title"`
	Description      pgtype.Text      `json:"description"`
	Code             pgtype.Text      `json:"code"`
	DiscountType     string           `json:"discount_type"`
	Status           string           `json:"status"`
	UsageLimit       pgtype.Int4      `json:"usage_limit"`
	PerCustomerLimit pgtype.Int4      `json:"per_customer_limit"`
	StartsAt         pgtype.Timestamp `json:"starts_at"`
	EndsAt           pgtype.Timestamp `json:"ends_at"`
}

func (q *Queries) CreateDiscount(ctx context.Context, arg CreateDiscountParams) (int64, error) {
	row := q.db.QueryRow(ctx, createDiscount,
		arg.Title,
		arg.Description,
		arg.Code,
		arg.DiscountType,
		arg.Status,
		arg.UsageLimit,
		arg.PerCustomerLimit,
		arg.StartsAt,
		arg.EndsAt,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getDiscountByCode = `-- name: GetDiscountByCode :one
SELECT id, title, description, code, discount_type, status, usage_limit, per_customer_limit, starts_at, ends_at
FROM discounts
WHERE code = $1
  AND starts_at <= NOW()
  AND (ends_at IS NULL OR ends_at >= NOW())
  AND status = 'active'
  AND (usage_limit IS NULL OR usage_count < usage_limit)
`

type GetDiscountByCodeRow struct {
	ID               int64            `json:"id"`
	Title            string           `json:"title"`
	Description      pgtype.Text      `json:"description"`
	Code             pgtype.Text      `json:"code"`
	DiscountType     string           `json:"discount_type"`
	Status           string           `json:"status"`
	UsageLimit       pgtype.Int4      `json:"usage_limit"`
	PerCustomerLimit pgtype.Int4      `json:"per_customer_limit"`
	StartsAt         pgtype.Timestamp `json:"starts_at"`
	EndsAt           pgtype.Timestamp `json:"ends_at"`
}

func (q *Queries) GetDiscountByCode(ctx context.Context, code pgtype.Text) (GetDiscountByCodeRow, error) {
	row := q.db.QueryRow(ctx, getDiscountByCode, code)
	var i GetDiscountByCodeRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Code,
		&i.DiscountType,
		&i.Status,
		&i.UsageLimit,
		&i.PerCustomerLimit,
		&i.StartsAt,
		&i.EndsAt,
	)
	return i, err
}

const getDiscountByID = `-- name: GetDiscountByID :one
SELECT id, title, description, code, discount_type, status, usage_limit, per_customer_limit, starts_at, ends_at
FROM discounts
WHERE id = $1
`

type GetDiscountByIDRow struct {
	ID               int64            `json:"id"`
	Title            string           `json:"title"`
	Description      pgtype.Text      `json:"description"`
	Code             pgtype.Text      `json:"code"`
	DiscountType     string           `json:"discount_type"`
	Status           string           `json:"status"`
	UsageLimit       pgtype.Int4      `json:"usage_limit"`
	PerCustomerLimit pgtype.Int4      `json:"per_customer_limit"`
	StartsAt         pgtype.Timestamp `json:"starts_at"`
	EndsAt           pgtype.Timestamp `json:"ends_at"`
}

func (q *Queries) GetDiscountByID(ctx context.Context, id int64) (GetDiscountByIDRow, error) {
	row := q.db.QueryRow(ctx, getDiscountByID, id)
	var i GetDiscountByIDRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Code,
		&i.DiscountType,
		&i.Status,
		&i.UsageLimit,
		&i.PerCustomerLimit,
		&i.StartsAt,
		&i.EndsAt,
	)
	return i, err
}

const getDiscountWithRelations = `-- name: GetDiscountWithRelations :one
SELECT
  d.id, d.title, d.description, d.code, d.discount_type, d.status, d.usage_limit, d.per_customer_limit, d.starts_at, d.ends_at,
  COALESCE(
    (
      SELECT json_agg(dc)
      FROM discount_conditions dc
      WHERE dc.discount_id = d.id
    ),
    '[]'::json
  ) AS conditions,
  COALESCE(
    (
      SELECT json_agg(de)
      FROM discount_effects de
      WHERE de.discount_id = d.id
    ),
    '[]'::json
  ) AS effects,
  COALESCE(
    (
      SELECT json_agg(dt)
      FROM discount_targets dt
      WHERE dt.discount_id = d.id
    ),
    '[]'::json
  ) AS targets
FROM discounts d
WHERE d.id = $1
LIMIT 1
`

type GetDiscountWithRelationsRow struct {
	ID               int64            `json:"id"`
	Title            string           `json:"title"`
	Description      pgtype.Text      `json:"description"`
	Code             pgtype.Text      `json:"code"`
	DiscountType     string           `json:"discount_type"`
	Status           string           `json:"status"`
	UsageLimit       pgtype.Int4      `json:"usage_limit"`
	PerCustomerLimit pgtype.Int4      `json:"per_customer_limit"`
	StartsAt         pgtype.Timestamp `json:"starts_at"`
	EndsAt           pgtype.Timestamp `json:"ends_at"`
	Conditions       interface{}      `json:"conditions"`
	Effects          interface{}      `json:"effects"`
	Targets          interface{}      `json:"targets"`
}

func (q *Queries) GetDiscountWithRelations(ctx context.Context, id int64) (GetDiscountWithRelationsRow, error) {
	row := q.db.QueryRow(ctx, getDiscountWithRelations, id)
	var i GetDiscountWithRelationsRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Code,
		&i.DiscountType,
		&i.Status,
		&i.UsageLimit,
		&i.PerCustomerLimit,
		&i.StartsAt,
		&i.EndsAt,
		&i.Conditions,
		&i.Effects,
		&i.Targets,
	)
	return i, err
}

const getValidDiscounts = `-- name: GetValidDiscounts :many
SELECT
    d.id, d.title, d.description, d.code, d.discount_type, d.status, d.usage_limit, d.per_customer_limit, d.starts_at, d.ends_at,
    COALESCE(
      (
        SELECT json_agg(dc)
        FROM discount_conditions dc
        WHERE dc.discount_id = d.id
      ),
      '[]'::json
    ) AS conditions,
    COALESCE(
      (
        SELECT json_agg(de)
        FROM discount_effects de
        WHERE de.discount_id = d.id
      ),
      '[]'::json
    ) AS effects
FROM
    discounts d
WHERE
    d.status = 'active'
    AND d.starts_at <= NOW()
    AND (d.ends_at IS NULL OR d.ends_at > NOW())
    AND (d.usage_limit IS NULL OR d.usage_count < d.usage_limit)
`

type GetValidDiscountsRow struct {
	ID               int64            `json:"id"`
	Title            string           `json:"title"`
	Description      pgtype.Text      `json:"description"`
	Code             pgtype.Text      `json:"code"`
	DiscountType     string           `json:"discount_type"`
	Status           string           `json:"status"`
	UsageLimit       pgtype.Int4      `json:"usage_limit"`
	PerCustomerLimit pgtype.Int4      `json:"per_customer_limit"`
	StartsAt         pgtype.Timestamp `json:"starts_at"`
	EndsAt           pgtype.Timestamp `json:"ends_at"`
	Conditions       interface{}      `json:"conditions"`
	Effects          interface{}      `json:"effects"`
}

func (q *Queries) GetValidDiscounts(ctx context.Context) ([]GetValidDiscountsRow, error) {
	rows, err := q.db.Query(ctx, getValidDiscounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetValidDiscountsRow
	for rows.Next() {
		var i GetValidDiscountsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Code,
			&i.DiscountType,
			&i.Status,
			&i.UsageLimit,
			&i.PerCustomerLimit,
			&i.StartsAt,
			&i.EndsAt,
			&i.Conditions,
			&i.Effects,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDiscounts = `-- name: ListDiscounts :many
SELECT id, title, description, code, discount_type, status, usage_limit, per_customer_limit, starts_at, ends_at
FROM discounts
ORDER BY created_at DESC
LIMIT $1
OFFSET $2
`

type ListDiscountsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListDiscountsRow struct {
	ID               int64            `json:"id"`
	Title            string           `json:"title"`
	Description      pgtype.Text      `json:"description"`
	Code             pgtype.Text      `json:"code"`
	DiscountType     string           `json:"discount_type"`
	Status           string           `json:"status"`
	UsageLimit       pgtype.Int4      `json:"usage_limit"`
	PerCustomerLimit pgtype.Int4      `json:"per_customer_limit"`
	StartsAt         pgtype.Timestamp `json:"starts_at"`
	EndsAt           pgtype.Timestamp `json:"ends_at"`
}

func (q *Queries) ListDiscounts(ctx context.Context, arg ListDiscountsParams) ([]ListDiscountsRow, error) {
	rows, err := q.db.Query(ctx, listDiscounts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDiscountsRow
	for rows.Next() {
		var i ListDiscountsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Code,
			&i.DiscountType,
			&i.Status,
			&i.UsageLimit,
			&i.PerCustomerLimit,
			&i.StartsAt,
			&i.EndsAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDiscount = `-- name: UpdateDiscount :one
UPDATE discounts
SET
  title = $2,
  description = $3,
  status = $4,
  usage_limit = $5,
  per_customer_limit = $6,
  starts_at = $7,
  ends_at = $8,
  updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id
`

type UpdateDiscountParams struct {
	ID               int64            `json:"id"`
	Title            string           `json:"title"`
	Description      pgtype.Text      `json:"description"`
	Status           string           `json:"status"`
	UsageLimit       pgtype.Int4      `json:"usage_limit"`
	PerCustomerLimit pgtype.Int4      `json:"per_customer_limit"`
	StartsAt         pgtype.Timestamp `json:"starts_at"`
	EndsAt           pgtype.Timestamp `json:"ends_at"`
}

func (q *Queries) UpdateDiscount(ctx context.Context, arg UpdateDiscountParams) (int64, error) {
	row := q.db.QueryRow(ctx, updateDiscount,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Status,
		arg.UsageLimit,
		arg.PerCustomerLimit,
		arg.StartsAt,
		arg.EndsAt,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const upsertDiscountUsageUsage = `-- name: UpsertDiscountUsageUsage :exec
INSERT INTO discounts (id, usage_count)
VALUES ($1, 1)
ON CONFLICT (id) DO UPDATE
SET usage_count = discounts.usage_count + 1
`

func (q *Queries) UpsertDiscountUsageUsage(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, upsertDiscountUsageUsage, id)
	return err
}
