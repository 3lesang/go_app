// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: hotspot.sql

package product_db

import (
	"context"
)

const bulkDeleteHotspots = `-- name: BulkDeleteHotspots :exec
DELETE FROM hotspots
WHERE id = ANY($1::bigint[])
`

func (q *Queries) BulkDeleteHotspots(ctx context.Context, dollar_1 []int64) error {
	_, err := q.db.Exec(ctx, bulkDeleteHotspots, dollar_1)
	return err
}

const countHotspots = `-- name: CountHotspots :one
SELECT
  COUNT(*)
FROM
  hotspots
`

func (q *Queries) CountHotspots(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countHotspots)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createHotspot = `-- name: CreateHotspot :one
INSERT INTO hotspots (file)
VALUES ($1)
RETURNING id
`

func (q *Queries) CreateHotspot(ctx context.Context, file string) (int64, error) {
	row := q.db.QueryRow(ctx, createHotspot, file)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getHotspot = `-- name: GetHotspot :one
SELECT
  h.id,
  h.file,
  COALESCE(
    json_agg(
      json_build_object(
        'id', ph.id,
        'product_id', ph.product_id,
        'x', ph.x,
        'y', ph.y,
        'product', json_build_object(
          'id', p.id,
          'name', p.name
        )
      )
    ) FILTER (WHERE ph.id IS NOT NULL),
    '[]'
  ) AS spots
FROM hotspots h
LEFT JOIN product_hotspots ph ON ph.hotspot_id = h.id
LEFT JOIN products p ON p.id = ph.product_id
WHERE h.id = $1
GROUP BY h.id
`

type GetHotspotRow struct {
	ID    int64       `json:"id"`
	File  string      `json:"file"`
	Spots interface{} `json:"spots"`
}

func (q *Queries) GetHotspot(ctx context.Context, id int64) (GetHotspotRow, error) {
	row := q.db.QueryRow(ctx, getHotspot, id)
	var i GetHotspotRow
	err := row.Scan(&i.ID, &i.File, &i.Spots)
	return i, err
}

const getHotspots = `-- name: GetHotspots :many
SELECT
  id,
  file
FROM
  hotspots
ORDER BY
  id
LIMIT
  $1
OFFSET
  $2
`

type GetHotspotsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetHotspots(ctx context.Context, arg GetHotspotsParams) ([]Hotspot, error) {
	rows, err := q.db.Query(ctx, getHotspots, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Hotspot
	for rows.Next() {
		var i Hotspot
		if err := rows.Scan(&i.ID, &i.File); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
