// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: order.sql

package product_db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const bulkDeleteOrders = `-- name: BulkDeleteOrders :exec
DELETE FROM orders
WHERE
  id = ANY ($1::bigint[])
`

func (q *Queries) BulkDeleteOrders(ctx context.Context, dollar_1 []int64) error {
	_, err := q.db.Exec(ctx, bulkDeleteOrders, dollar_1)
	return err
}

const checkOrderCreated = `-- name: CheckOrderCreated :one
SELECT
  id
FROM
  orders
WHERE
  id = $1
`

func (q *Queries) CheckOrderCreated(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRow(ctx, checkOrderCreated, id)
	err := row.Scan(&id)
	return id, err
}

const countOrders = `-- name: CountOrders :one
SELECT
  COUNT(*)
FROM
  orders
`

func (q *Queries) CountOrders(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countOrders)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOrdersByStatus = `-- name: CountOrdersByStatus :one
SELECT
  COUNT(*)
FROM
  orders
WHERE status = $1
`

func (q *Queries) CountOrdersByStatus(ctx context.Context, status pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, countOrdersByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countStatusOrder = `-- name: CountStatusOrder :one
SELECT
  SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) AS pending_count,
  SUM(CASE WHEN status = 'confirmed' THEN 1 ELSE 0 END) AS confirmed_count,
  SUM(CASE WHEN status = 'shipping' THEN 1 ELSE 0 END) AS shipping_count,
  SUM(CASE WHEN status = 'shipped' THEN 1 ELSE 0 END) AS shipped_count,
  SUM(CASE WHEN status = 'cancelled' THEN 1 ELSE 0 END) AS cancelled_count
FROM orders
`

type CountStatusOrderRow struct {
	PendingCount   int64 `json:"pending_count"`
	ConfirmedCount int64 `json:"confirmed_count"`
	ShippingCount  int64 `json:"shipping_count"`
	ShippedCount   int64 `json:"shipped_count"`
	CancelledCount int64 `json:"cancelled_count"`
}

func (q *Queries) CountStatusOrder(ctx context.Context) (CountStatusOrderRow, error) {
	row := q.db.QueryRow(ctx, countStatusOrder)
	var i CountStatusOrderRow
	err := row.Scan(
		&i.PendingCount,
		&i.ConfirmedCount,
		&i.ShippingCount,
		&i.ShippedCount,
		&i.CancelledCount,
	)
	return i, err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO
  orders (
    code,
    total_amount,
    discount_amount,
    shipping_fee_amount,
    shipping_address_id
  )
VALUES
  ($1, $2, $3, $4, $5)
RETURNING
  id
`

type CreateOrderParams struct {
	Code              string      `json:"code"`
	TotalAmount       int32       `json:"total_amount"`
	DiscountAmount    int32       `json:"discount_amount"`
	ShippingFeeAmount pgtype.Int4 `json:"shipping_fee_amount"`
	ShippingAddressID pgtype.Int8 `json:"shipping_address_id"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (int64, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.Code,
		arg.TotalAmount,
		arg.DiscountAmount,
		arg.ShippingFeeAmount,
		arg.ShippingAddressID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getOrder = `-- name: GetOrder :one
SELECT
  o.id,
  o.code,
  o.total_amount,
  o.discount_amount,
  o.shipping_fee_amount,
  o.status,
  o.created_at,  
  a.full_name,
  a.phone,
  a.address_line,
  a.email,
  (
    SELECT COALESCE(
      json_agg(
        json_build_object(
          'id', oi.id,
          'product_id', p.id,
          'product_sku', p.sku,
          'variant_sku', v.sku,
          'name', p.name,
          'quantity', oi.quantity,
          'sale_price', oi.sale_price,
          'options', (
            SELECT COALESCE(
              json_agg(
                json_build_object(
                  'option', o.name,
                  'value', ov.name
                )
              ),
              '[]'::json
            )
            FROM variant_options vo
            LEFT JOIN options o ON o.id = vo.option_id
            LEFT JOIN option_values ov ON ov.id = vo.option_value_id 
            WHERE vo.variant_id = oi.variant_id        
          )
        )
      ) FILTER (WHERE oi.id IS NOT NULL),
      '[]'::json
    )
    FROM order_items oi
    LEFT JOIN products p ON p.id = oi.product_id
    LEFT JOIN variants v ON v.id = oi.variant_id
    WHERE oi.order_id = o.id
  ) AS items
FROM
  orders o
  LEFT JOIN addresses a ON o.shipping_address_id = a.id
WHERE
  o.id = $1
`

type GetOrderRow struct {
	ID                int64              `json:"id"`
	Code              string             `json:"code"`
	TotalAmount       int32              `json:"total_amount"`
	DiscountAmount    int32              `json:"discount_amount"`
	ShippingFeeAmount pgtype.Int4        `json:"shipping_fee_amount"`
	Status            pgtype.Text        `json:"status"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	FullName          pgtype.Text        `json:"full_name"`
	Phone             pgtype.Text        `json:"phone"`
	AddressLine       pgtype.Text        `json:"address_line"`
	Email             pgtype.Text        `json:"email"`
	Items             interface{}        `json:"items"`
}

func (q *Queries) GetOrder(ctx context.Context, id int64) (GetOrderRow, error) {
	row := q.db.QueryRow(ctx, getOrder, id)
	var i GetOrderRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.TotalAmount,
		&i.DiscountAmount,
		&i.ShippingFeeAmount,
		&i.Status,
		&i.CreatedAt,
		&i.FullName,
		&i.Phone,
		&i.AddressLine,
		&i.Email,
		&i.Items,
	)
	return i, err
}

const getOrders = `-- name: GetOrders :many
SELECT
  o.id,
  o.code,
  o.total_amount,
  o.discount_amount,
  o.shipping_fee_amount,
  o.status,
  o.created_at,
  a.full_name,
  a.phone,
  a.address_line,
  a.email,
  (
    SELECT COALESCE(
      json_agg(
        json_build_object(
          'id', oi.id,
          'product_id', p.id,
          'product_sku', p.sku,
          'variant_sku', v.sku,
          'name', p.name,
          'quantity', oi.quantity,
          'sale_price', oi.sale_price,
          'options', (
            SELECT COALESCE(
              json_agg(
                json_build_object(
                  'option', o.name,
                  'value', ov.name
                )
              ),
              '[]'::json
            )
            FROM variant_options vo
            LEFT JOIN options o ON o.id = vo.option_id
            LEFT JOIN option_values ov ON ov.id = vo.option_value_id 
            WHERE vo.variant_id = oi.variant_id        
          )
        )
      ) FILTER (WHERE oi.id IS NOT NULL),
      '[]'::json
    )
    FROM order_items oi
    LEFT JOIN products p ON p.id = oi.product_id
    LEFT JOIN variants v ON v.id = oi.variant_id
    WHERE oi.order_id = o.id
  ) AS items
FROM
  orders o
  LEFT JOIN addresses a ON o.shipping_address_id = a.id
ORDER BY o.id DESC
LIMIT
  $1
OFFSET
  $2
`

type GetOrdersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetOrdersRow struct {
	ID                int64              `json:"id"`
	Code              string             `json:"code"`
	TotalAmount       int32              `json:"total_amount"`
	DiscountAmount    int32              `json:"discount_amount"`
	ShippingFeeAmount pgtype.Int4        `json:"shipping_fee_amount"`
	Status            pgtype.Text        `json:"status"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	FullName          pgtype.Text        `json:"full_name"`
	Phone             pgtype.Text        `json:"phone"`
	AddressLine       pgtype.Text        `json:"address_line"`
	Email             pgtype.Text        `json:"email"`
	Items             interface{}        `json:"items"`
}

func (q *Queries) GetOrders(ctx context.Context, arg GetOrdersParams) ([]GetOrdersRow, error) {
	rows, err := q.db.Query(ctx, getOrders, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrdersRow
	for rows.Next() {
		var i GetOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.TotalAmount,
			&i.DiscountAmount,
			&i.ShippingFeeAmount,
			&i.Status,
			&i.CreatedAt,
			&i.FullName,
			&i.Phone,
			&i.AddressLine,
			&i.Email,
			&i.Items,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersByStatus = `-- name: GetOrdersByStatus :many
SELECT
  o.id,
  o.code,
  o.total_amount,
  o.discount_amount,
  o.shipping_fee_amount,
  o.status,
  o.created_at,
  a.full_name,
  a.phone,
  a.address_line,
  a.email,
  (
    SELECT COALESCE(
      json_agg(
        json_build_object(
          'id', oi.id,
          'product_id', p.id,
          'product_sku', p.sku,
          'variant_sku', v.sku,
          'name', p.name,
          'quantity', oi.quantity,
          'sale_price', oi.sale_price,
          'options', (
            SELECT COALESCE(
              json_agg(
                json_build_object(
                  'option', o.name,
                  'value', ov.name
                )
              ),
              '[]'::json
            )
            FROM variant_options vo
            LEFT JOIN options o ON o.id = vo.option_id
            LEFT JOIN option_values ov ON ov.id = vo.option_value_id 
            WHERE vo.variant_id = oi.variant_id        
          )
        )
      ) FILTER (WHERE oi.id IS NOT NULL),
      '[]'::json
    )
    FROM order_items oi
    LEFT JOIN products p ON p.id = oi.product_id
    LEFT JOIN variants v ON v.id = oi.variant_id
    WHERE oi.order_id = o.id
  ) AS items
FROM
  orders o
  LEFT JOIN addresses a ON o.shipping_address_id = a.id
WHERE o.status = $3
ORDER BY o.id DESC
LIMIT
  $1
OFFSET
  $2
`

type GetOrdersByStatusParams struct {
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
	Status pgtype.Text `json:"status"`
}

type GetOrdersByStatusRow struct {
	ID                int64              `json:"id"`
	Code              string             `json:"code"`
	TotalAmount       int32              `json:"total_amount"`
	DiscountAmount    int32              `json:"discount_amount"`
	ShippingFeeAmount pgtype.Int4        `json:"shipping_fee_amount"`
	Status            pgtype.Text        `json:"status"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	FullName          pgtype.Text        `json:"full_name"`
	Phone             pgtype.Text        `json:"phone"`
	AddressLine       pgtype.Text        `json:"address_line"`
	Email             pgtype.Text        `json:"email"`
	Items             interface{}        `json:"items"`
}

func (q *Queries) GetOrdersByStatus(ctx context.Context, arg GetOrdersByStatusParams) ([]GetOrdersByStatusRow, error) {
	rows, err := q.db.Query(ctx, getOrdersByStatus, arg.Limit, arg.Offset, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrdersByStatusRow
	for rows.Next() {
		var i GetOrdersByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.TotalAmount,
			&i.DiscountAmount,
			&i.ShippingFeeAmount,
			&i.Status,
			&i.CreatedAt,
			&i.FullName,
			&i.Phone,
			&i.AddressLine,
			&i.Email,
			&i.Items,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrder = `-- name: UpdateOrder :exec
UPDATE orders
SET status = $2,
    cancel_reason = $3
WHERE id = $1
`

type UpdateOrderParams struct {
	ID           int64       `json:"id"`
	Status       pgtype.Text `json:"status"`
	CancelReason pgtype.Text `json:"cancel_reason"`
}

func (q *Queries) UpdateOrder(ctx context.Context, arg UpdateOrderParams) error {
	_, err := q.db.Exec(ctx, updateOrder, arg.ID, arg.Status, arg.CancelReason)
	return err
}
