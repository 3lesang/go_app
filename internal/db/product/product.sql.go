// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: product.sql

package product_db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const bulkDeleteProducts = `-- name: BulkDeleteProducts :exec
DELETE FROM products
WHERE
  id = ANY ($1::bigint[])
`

func (q *Queries) BulkDeleteProducts(ctx context.Context, dollar_1 []int64) error {
	_, err := q.db.Exec(ctx, bulkDeleteProducts, dollar_1)
	return err
}

const countProducts = `-- name: CountProducts :one
SELECT
  COUNT(*)
FROM
  products
`

func (q *Queries) CountProducts(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countProducts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProductsByCategory = `-- name: CountProductsByCategory :one
SELECT
  COUNT(*)
FROM
  products
WHERE
  category_id = $1
`

func (q *Queries) CountProductsByCategory(ctx context.Context, categoryID pgtype.Int8) (int64, error) {
	row := q.db.QueryRow(ctx, countProductsByCategory, categoryID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSearchProducts = `-- name: CountSearchProducts :one
SELECT COUNT(*) AS total
FROM products
WHERE ($1 = '' OR name LIKE '%' || $1 || '%')
`

func (q *Queries) CountSearchProducts(ctx context.Context, dollar_1 interface{}) (int64, error) {
	row := q.db.QueryRow(ctx, countSearchProducts, dollar_1)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO
  products (
    name,
    slug,
    origin_price,
    sale_price,
    meta_title,
    meta_description,
    category_id
  )
VALUES
  ($1, $2, $3, $4, $5, $6, $7)
RETURNING
  id
`

type CreateProductParams struct {
	Name            string      `json:"name"`
	Slug            string      `json:"slug"`
	OriginPrice     int32       `json:"origin_price"`
	SalePrice       int32       `json:"sale_price"`
	MetaTitle       string      `json:"meta_title"`
	MetaDescription string      `json:"meta_description"`
	CategoryID      pgtype.Int8 `json:"category_id"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (int64, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.Name,
		arg.Slug,
		arg.OriginPrice,
		arg.SalePrice,
		arg.MetaTitle,
		arg.MetaDescription,
		arg.CategoryID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getProduct = `-- name: GetProduct :one
SELECT
  id,
  name,
  slug,
  origin_price,
  sale_price,
  meta_title,
  meta_description,
  category_id,
  is_active
FROM
  products
WHERE
  id = $1
LIMIT
  1
`

type GetProductRow struct {
	ID              int64       `json:"id"`
	Name            string      `json:"name"`
	Slug            string      `json:"slug"`
	OriginPrice     int32       `json:"origin_price"`
	SalePrice       int32       `json:"sale_price"`
	MetaTitle       string      `json:"meta_title"`
	MetaDescription string      `json:"meta_description"`
	CategoryID      pgtype.Int8 `json:"category_id"`
	IsActive        bool        `json:"is_active"`
}

func (q *Queries) GetProduct(ctx context.Context, id int64) (GetProductRow, error) {
	row := q.db.QueryRow(ctx, getProduct, id)
	var i GetProductRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.OriginPrice,
		&i.SalePrice,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.CategoryID,
		&i.IsActive,
	)
	return i, err
}

const getProductBySlug = `-- name: GetProductBySlug :one
SELECT
  p.id,
  p.name,
  p.slug,
  p.origin_price,
  p.sale_price,
  p.meta_title,
  p.meta_description,
  p.category_id,
  p.is_active,
  (
    SELECT
      COALESCE(json_agg(pf.name), '[]'::json)
    FROM
      product_files pf
    WHERE
      pf.product_id = p.id
  ) as files,
  (
    SELECT
      COALESCE(
        json_agg(
          json_build_object(
            'id',
            o.id,
            'name',
            o.name,
            'values',
            (
              SELECT
                COALESCE(
                  json_agg(json_build_object('id', ov.name, 'name', ov.name)),
                  '[]'::json
                )
              FROM
                option_values ov
              WHERE
                ov.option_id = o.id
            )
          )
        ),
        '[]'::json
      )
    FROM
      options o
    WHERE
      o.product_id = p.id
  ) as options,
  (
    SELECT
      COALESCE(
        json_agg(
          json_build_object(
            'id',
            v.id,
            'sku',
            v.sku,
            'origin_price',
            v.origin_price,
            'sale_price',
            v.sale_price,
            'file',
            v.file,
            'options',
            (
              SELECT
                COALESCE(jsonb_object_agg(o.name, ov.name), '{}'::jsonb)
              FROM
                variant_options vo
                JOIN options o ON o.id = vo.option_id
                JOIN option_values ov ON ov.id = vo.option_value_id
              WHERE
                vo.variant_id = v.id
            )
          )
          ORDER BY
            v.sale_price ASC
        ),
        '[]'::json
      )
    FROM
      variants v
    WHERE
      v.product_id = p.id
  ) AS variants
FROM
  products p
WHERE
  slug = $1
LIMIT
  1
`

type GetProductBySlugRow struct {
	ID              int64       `json:"id"`
	Name            string      `json:"name"`
	Slug            string      `json:"slug"`
	OriginPrice     int32       `json:"origin_price"`
	SalePrice       int32       `json:"sale_price"`
	MetaTitle       string      `json:"meta_title"`
	MetaDescription string      `json:"meta_description"`
	CategoryID      pgtype.Int8 `json:"category_id"`
	IsActive        bool        `json:"is_active"`
	Files           interface{} `json:"files"`
	Options         interface{} `json:"options"`
	Variants        interface{} `json:"variants"`
}

func (q *Queries) GetProductBySlug(ctx context.Context, slug string) (GetProductBySlugRow, error) {
	row := q.db.QueryRow(ctx, getProductBySlug, slug)
	var i GetProductBySlugRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.OriginPrice,
		&i.SalePrice,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.CategoryID,
		&i.IsActive,
		&i.Files,
		&i.Options,
		&i.Variants,
	)
	return i, err
}

const getProducts = `-- name: GetProducts :many
SELECT
  p.id,
  p.name,
  p.is_active,
  f.name AS file
FROM
  products p
  LEFT JOIN LATERAL (
    SELECT
      name
    FROM
      product_files
    WHERE
      product_id = p.id
      AND is_primary = true
    LIMIT
      1
  ) f ON true
ORDER BY
  created_at DESC
LIMIT
  $1
OFFSET
  $2
`

type GetProductsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetProductsRow struct {
	ID       int64       `json:"id"`
	Name     string      `json:"name"`
	IsActive bool        `json:"is_active"`
	File     pgtype.Text `json:"file"`
}

func (q *Queries) GetProducts(ctx context.Context, arg GetProductsParams) ([]GetProductsRow, error) {
	rows, err := q.db.Query(ctx, getProducts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsRow
	for rows.Next() {
		var i GetProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.IsActive,
			&i.File,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByCategory = `-- name: GetProductsByCategory :many
SELECT
  p.id,
  p.name,
  p.origin_price,
  p.slug,
  p.sale_price,
  (
    SELECT
      COALESCE(json_agg(pf.name))
    FROM
      product_files pf
    WHERE
      pf.product_id = p.id
  ) as files
FROM
  products p
WHERE
  category_id = $3
LIMIT
  $1
OFFSET
  $2
`

type GetProductsByCategoryParams struct {
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
	CategoryID pgtype.Int8 `json:"category_id"`
}

type GetProductsByCategoryRow struct {
	ID          int64       `json:"id"`
	Name        string      `json:"name"`
	OriginPrice int32       `json:"origin_price"`
	Slug        string      `json:"slug"`
	SalePrice   int32       `json:"sale_price"`
	Files       interface{} `json:"files"`
}

func (q *Queries) GetProductsByCategory(ctx context.Context, arg GetProductsByCategoryParams) ([]GetProductsByCategoryRow, error) {
	rows, err := q.db.Query(ctx, getProductsByCategory, arg.Limit, arg.Offset, arg.CategoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsByCategoryRow
	for rows.Next() {
		var i GetProductsByCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OriginPrice,
			&i.Slug,
			&i.SalePrice,
			&i.Files,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProducts = `-- name: SearchProducts :many
SELECT
    p.id,
    p.name,
    p.slug,
    p.origin_price,
    p.sale_price,
    (
        SELECT pf.name
        FROM product_files pf
        WHERE pf.product_id = p.id
          AND pf.is_primary = TRUE
        ORDER BY pf.no ASC
        LIMIT 1
    ) AS file
FROM products p
WHERE ($1 = '' OR p.name ILIKE '%' || $1 || '%')
ORDER BY p.created_at DESC
LIMIT $2 OFFSET $3
`

type SearchProductsParams struct {
	Column1 interface{} `json:"column_1"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type SearchProductsRow struct {
	ID          int64       `json:"id"`
	Name        string      `json:"name"`
	Slug        string      `json:"slug"`
	OriginPrice int32       `json:"origin_price"`
	SalePrice   int32       `json:"sale_price"`
	File        pgtype.Text `json:"file"`
}

func (q *Queries) SearchProducts(ctx context.Context, arg SearchProductsParams) ([]SearchProductsRow, error) {
	rows, err := q.db.Query(ctx, searchProducts, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchProductsRow
	for rows.Next() {
		var i SearchProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.OriginPrice,
			&i.SalePrice,
			&i.File,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :exec
UPDATE products
SET
  name = $2,
  slug = $3,
  origin_price = $4,
  sale_price = $5,
  meta_title = $6,
  meta_description = $7,
  category_id = $8
WHERE
  id = $1
`

type UpdateProductParams struct {
	ID              int64       `json:"id"`
	Name            string      `json:"name"`
	Slug            string      `json:"slug"`
	OriginPrice     int32       `json:"origin_price"`
	SalePrice       int32       `json:"sale_price"`
	MetaTitle       string      `json:"meta_title"`
	MetaDescription string      `json:"meta_description"`
	CategoryID      pgtype.Int8 `json:"category_id"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) error {
	_, err := q.db.Exec(ctx, updateProduct,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.OriginPrice,
		arg.SalePrice,
		arg.MetaTitle,
		arg.MetaDescription,
		arg.CategoryID,
	)
	return err
}
