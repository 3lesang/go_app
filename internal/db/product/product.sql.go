// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: product.sql

package product_db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const bulkDeleteProducts = `-- name: BulkDeleteProducts :exec
DELETE FROM products
WHERE
  id = ANY ($1::bigint[])
`

func (q *Queries) BulkDeleteProducts(ctx context.Context, dollar_1 []int64) error {
	_, err := q.db.Exec(ctx, bulkDeleteProducts, dollar_1)
	return err
}

const countProducts = `-- name: CountProducts :one
SELECT
  COUNT(*)
FROM
  products
`

func (q *Queries) CountProducts(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countProducts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO
  products (
    name,
    slug,
    origin_price,
    sale_price,
    meta_title,
    meta_description,
    category_id
  )
VALUES
  ($1, $2, $3, $4, $5, $6, $7)
RETURNING
  id
`

type CreateProductParams struct {
	Name            string      `json:"name"`
	Slug            string      `json:"slug"`
	OriginPrice     int32       `json:"origin_price"`
	SalePrice       int32       `json:"sale_price"`
	MetaTitle       string      `json:"meta_title"`
	MetaDescription string      `json:"meta_description"`
	CategoryID      pgtype.Int8 `json:"category_id"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (int64, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.Name,
		arg.Slug,
		arg.OriginPrice,
		arg.SalePrice,
		arg.MetaTitle,
		arg.MetaDescription,
		arg.CategoryID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getProduct = `-- name: GetProduct :one
SELECT
  id,
  name,
  slug,
  origin_price,
  sale_price,
  meta_title,
  meta_description,
  category_id,
  is_active
FROM
  products
WHERE
  id = $1
LIMIT
  1
`

type GetProductRow struct {
	ID              int64       `json:"id"`
	Name            string      `json:"name"`
	Slug            string      `json:"slug"`
	OriginPrice     int32       `json:"origin_price"`
	SalePrice       int32       `json:"sale_price"`
	MetaTitle       string      `json:"meta_title"`
	MetaDescription string      `json:"meta_description"`
	CategoryID      pgtype.Int8 `json:"category_id"`
	IsActive        bool        `json:"is_active"`
}

func (q *Queries) GetProduct(ctx context.Context, id int64) (GetProductRow, error) {
	row := q.db.QueryRow(ctx, getProduct, id)
	var i GetProductRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.OriginPrice,
		&i.SalePrice,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.CategoryID,
		&i.IsActive,
	)
	return i, err
}

const getProducts = `-- name: GetProducts :many
SELECT
  p.id,
  p.name,
  p.is_active,
  f.name AS file
FROM
  products p
  LEFT JOIN LATERAL (
    SELECT
      name
    FROM
      product_files
    WHERE
      product_id = p.id
      AND is_primary = true
    LIMIT
      1
  ) f ON true
ORDER BY
  created_at DESC
LIMIT
  $1
OFFSET
  $2
`

type GetProductsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetProductsRow struct {
	ID       int64       `json:"id"`
	Name     string      `json:"name"`
	IsActive bool        `json:"is_active"`
	File     pgtype.Text `json:"file"`
}

func (q *Queries) GetProducts(ctx context.Context, arg GetProductsParams) ([]GetProductsRow, error) {
	rows, err := q.db.Query(ctx, getProducts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsRow
	for rows.Next() {
		var i GetProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.IsActive,
			&i.File,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :exec
UPDATE products
SET
  name = $2,
  slug = $3,
  origin_price = $4,
  sale_price = $5,
  meta_title = $6,
  meta_description = $7,
  category_id = $8
WHERE
  id = $1
`

type UpdateProductParams struct {
	ID              int64       `json:"id"`
	Name            string      `json:"name"`
	Slug            string      `json:"slug"`
	OriginPrice     int32       `json:"origin_price"`
	SalePrice       int32       `json:"sale_price"`
	MetaTitle       string      `json:"meta_title"`
	MetaDescription string      `json:"meta_description"`
	CategoryID      pgtype.Int8 `json:"category_id"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) error {
	_, err := q.db.Exec(ctx, updateProduct,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.OriginPrice,
		arg.SalePrice,
		arg.MetaTitle,
		arg.MetaDescription,
		arg.CategoryID,
	)
	return err
}
