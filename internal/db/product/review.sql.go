// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: review.sql

package product_db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const bulkDeleteReviews = `-- name: BulkDeleteReviews :exec
DELETE FROM reviews
WHERE
  id = ANY ($1::bigint[])
`

func (q *Queries) BulkDeleteReviews(ctx context.Context, dollar_1 []int64) error {
	_, err := q.db.Exec(ctx, bulkDeleteReviews, dollar_1)
	return err
}

const countReviewsByProduct = `-- name: CountReviewsByProduct :one
SELECT
  COUNT(*)
FROM
  reviews
WHERE
  product_id = $1
`

func (q *Queries) CountReviewsByProduct(ctx context.Context, productID pgtype.Int8) (int64, error) {
	row := q.db.QueryRow(ctx, countReviewsByProduct, productID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createReview = `-- name: CreateReview :one
INSERT INTO
  reviews (
    rating,
    comment,
    has_file,
    product_id,
    customer_id
  )
VALUES
  ($1, $2, $3, $4, $5)
RETURNING
  id
`

type CreateReviewParams struct {
	Rating     pgtype.Int4 `json:"rating"`
	Comment    pgtype.Text `json:"comment"`
	HasFile    bool        `json:"has_file"`
	ProductID  pgtype.Int8 `json:"product_id"`
	CustomerID int64       `json:"customer_id"`
}

func (q *Queries) CreateReview(ctx context.Context, arg CreateReviewParams) (int64, error) {
	row := q.db.QueryRow(ctx, createReview,
		arg.Rating,
		arg.Comment,
		arg.HasFile,
		arg.ProductID,
		arg.CustomerID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getAverageRatingByProduct = `-- name: GetAverageRatingByProduct :one
SELECT
  AVG(rating) AS average_rating,
  COUNT(*) AS total_reviews
FROM
  reviews
WHERE
  product_id = $1
`

type GetAverageRatingByProductRow struct {
	AverageRating float64 `json:"average_rating"`
	TotalReviews  int64   `json:"total_reviews"`
}

func (q *Queries) GetAverageRatingByProduct(ctx context.Context, productID pgtype.Int8) (GetAverageRatingByProductRow, error) {
	row := q.db.QueryRow(ctx, getAverageRatingByProduct, productID)
	var i GetAverageRatingByProductRow
	err := row.Scan(&i.AverageRating, &i.TotalReviews)
	return i, err
}

const getReviewFilesByProduct = `-- name: GetReviewFilesByProduct :many
SELECT
  r.comment,
  r.rating,
  (
    SELECT
      COALESCE(json_agg(rf.name))
    FROM
      review_files rf
    WHERE
      rf.review_id = r.id
  ) AS files,
  (
    SELECT
      COALESCE(
        json_build_object('id', c.id, 'name', c.name, 'avatar', c.avatar),
        '{}'::json
      )
    FROM
      customers c
    WHERE
      c.id = r.customer_id
  ) AS customer
FROM
  reviews r
WHERE
  r.product_id = $1 and r.has_file = true
LIMIT
  8
OFFSET
  0
`

type GetReviewFilesByProductRow struct {
	Comment  pgtype.Text `json:"comment"`
	Rating   pgtype.Int4 `json:"rating"`
	Files    interface{} `json:"files"`
	Customer interface{} `json:"customer"`
}

func (q *Queries) GetReviewFilesByProduct(ctx context.Context, productID pgtype.Int8) ([]GetReviewFilesByProductRow, error) {
	rows, err := q.db.Query(ctx, getReviewFilesByProduct, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReviewFilesByProductRow
	for rows.Next() {
		var i GetReviewFilesByProductRow
		if err := rows.Scan(
			&i.Comment,
			&i.Rating,
			&i.Files,
			&i.Customer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReviewsByProductID = `-- name: GetReviewsByProductID :many
SELECT
  r.id,
  r.rating,
  r.comment,
  (
    SELECT
      COALESCE(json_agg(rf.name))
    FROM
      review_files rf
    WHERE
      rf.review_id = r.id
  ) AS files,
  (
    SELECT
      COALESCE(
        json_build_object('id', c.id, 'name', c.name, 'avatar', c.avatar),
        '{}'::json
      )
    FROM
      customers c
    WHERE
      c.id = r.customer_id
  ) AS customer
FROM
  reviews r
WHERE
  r.product_id = $1
  AND (
    $2::int IS NULL
    OR r.rating = $2
  )
  AND (
    $3::boolean IS NULL
    OR (r.has_file = $3)
  )
ORDER BY
  CASE
    WHEN $4::int = 1 THEN r.created_at
  END DESC,
  CASE
    WHEN $4::int = 0 THEN r.created_at
  END ASC
LIMIT
  $6
OFFSET
  $5
`

type GetReviewsByProductIDParams struct {
	ProductID   pgtype.Int8 `json:"product_id"`
	Rating      pgtype.Int4 `json:"rating"`
	HasFile     pgtype.Bool `json:"has_file"`
	SortFlag    pgtype.Int4 `json:"sort_flag"`
	OffsetCount int32       `json:"offset_count"`
	LimitCount  int32       `json:"limit_count"`
}

type GetReviewsByProductIDRow struct {
	ID       int64       `json:"id"`
	Rating   pgtype.Int4 `json:"rating"`
	Comment  pgtype.Text `json:"comment"`
	Files    interface{} `json:"files"`
	Customer interface{} `json:"customer"`
}

func (q *Queries) GetReviewsByProductID(ctx context.Context, arg GetReviewsByProductIDParams) ([]GetReviewsByProductIDRow, error) {
	rows, err := q.db.Query(ctx, getReviewsByProductID,
		arg.ProductID,
		arg.Rating,
		arg.HasFile,
		arg.SortFlag,
		arg.OffsetCount,
		arg.LimitCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReviewsByProductIDRow
	for rows.Next() {
		var i GetReviewsByProductIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Rating,
			&i.Comment,
			&i.Files,
			&i.Customer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
